# Win

## Metasploit post modules

Scanning privli escalation vulnerabilities

Not Offline requires active session

<pre><code><strong>meterpreter> run post/multi/recon/local_exploit_suggester
</strong></code></pre>

| Command                                 | Description                                    |
| --------------------------------------- | ---------------------------------------------- |
| `getsystem`                             | Try to escalate to SYSTEM privileges. WIN ONLY |
| `getprivs  OR windows/gather/win_privs` | see what privileges we have                    |

## Windows exploit suggester

#### ✅ Standalone Python script

#### 🔧 **How it works:**

* Takes a `systeminfo` output from a Windows host.
* Compares it to a local database of **Microsoft security bulletins (patches)**.
* Identifies **missing patches** and maps them to **known privilege escalation exploits** (from ExploitDB, MS bulletins, etc.).
* OFFLINE

{% embed url="https://github.com/bitsadmin/wesng" %}

{% embed url="https://github.com/Pwnistry/Windows-Exploit-Suggester-python3" %}

## &#x20;Access Token Impersonation

* winlogon.exe procces

<figure><img src="../../../../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

<p align="center"><strong>!!! IMPORTANT !!!</strong></p>

<figure><img src="../../../../.gitbook/assets/image (2) (1).png" alt=""><figcaption></figcaption></figure>

***

### 🪪 What Is an Access Token (Windows Security)?

An **Access Token** in Windows is a **data structure** that contains **security information** about a **logged-in user** or **process**.

It tells the system:

* **Who** you are
* **What** you can do (privileges)
* **Where** you belong (groups)

Think of it like your **"security passport"** for Windows. When you log in, Windows creates a token and attaches it to every process you run.

{% hint style="warning" %}
Only metepreter gets elvated privalages not the actual shell
{% endhint %}

***

### 🔍 What’s Inside an Access Token?

| Component           | Description                                                                |
| ------------------- | -------------------------------------------------------------------------- |
| **User SID**        | The unique ID of the user                                                  |
| **Group SIDs**      | The user’s group memberships (e.g., Administrators, Users)                 |
| **Privileges**      | Rights like `SeDebugPrivilege`, `SeImpersonatePrivilege`, etc.             |
| **Integrity Level** | Tells Windows how trusted the process is (e.g., low, medium, high, system) |
| **Linked Token**    | For UAC (Standard + Elevated token on admin accounts)                      |

***

### 🧠 What is Access Token Impersonation (for Privilege Escalation)?

**Access token impersonation** allows an attacker to **run code with the privileges of a more powerful user (like SYSTEM or Admin)** by stealing or impersonating that user's **access token** — without knowing their credentials.

🔒 **An access token = a "proof of identity" + permissions** for a user session. Windows uses it to control what you can do.

***

### 🛠️ How It Enables Privilege Escalation

After gaining **initial access** (e.g., as a low-privilege user), the attacker looks for a way to **steal or impersonate a token** that belongs to a **higher-privileged** process or session (e.g., Administrator or SYSTEM). Once impersonated, the attacker can:

* **Spawn processes** as that higher-privileged user
* **Access files**, **install services**, or **execute commands** they normally can’t

***

### Metasploit Module

📦 Module used: Incognito

🔐 Requirments: SeImpersonatePrivilege

> `getprivs` see our privileges

Using Incognito

```
meterpreter> load incognito
```

Commands:

* `list_tokens -u`#   Show available user tokens
* `list_tokens -g` # Show available groups
* `impersonate_token` "DOMAIN\Administrator" # Impersonate a token
* `getuid` # Confirm elevated identity

## &#x20;UAC

First we need to check if our current user its inside the adminstrator group otherwise we cant bypass UAC

To check we run

```
net localgroup administrators
```

### UACme

{% embed url="https://github.com/hfiref0x/UACME" %}

